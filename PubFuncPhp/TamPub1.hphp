<?php
/**
 * Created by PhpStorm.
 * User: Jesse Tam
 * Date: 2019/6/2 0002
 * Time: 下午 6:22
 */

namespace TamPub1;

class DelphiString {
    public static $encoding = "utf-8";

    /**
     * 兼容Delphi的从1开始的copy
     * @param string $value 需要拷贝的字串
     * @param int $startPos 从1开始的起始位置
     * @param int $len 需要拷贝的长度
     * @return string 子字符串
     */
    public static function copy(string $value, int $startPos, int $len): string {
        return StringFunc::copy($value, $startPos - 1, $len);
    }

    /**
     * 兼容Delphi的从1开始的搜索
     * @param string $subString 需要搜索的字串
     * @param string $value 被搜索的字串
     * @param int $startPos 起始搜索位置（从1开始）
     * @return int 大于等于1标识搜索到了，否则返回0
     */
    public static function pos(string $subString, string $value, int $startPos): int {
        return StringFunc::pos($subString, $value, $startPos - 1) + 1;
    }

    /**
     * 获取字元
     * @param string $destString 需要分析的字符串
     * @param int $position 位置指针
     * @param string $breakValueList 结束标记字符列表
     * @return string token
     */
    public static function getToken(string $destString, int &$position, string $breakValueList): string {
        $result = "";
        for ($i = $position - 1; $i < StringFunc::length($destString); $i++) {
            if (self::pos(StringFunc::charAt($destString, $i), $breakValueList, 1) > 0) break;
            $result = $result . StringFunc::charAt($destString, $i);
        }
        $position = $i + 1;
        return $result;
    }

    public static function getBlank(string $destString, int &$position): string {
        $result = "";
        for ($i = $position - 1; $i < StringFunc::length($destString); $i++) {
            if (StringFunc::getCharCode(StringFunc::charAt($destString, $i)) > 0x20) break;
            $result .= StringFunc::charAt($destString, $i);
        }
        $position = $i + 1;
        return $result;
    }

    public static function getBlankAndToken(string $destString, int &$position, string $breakValueList): string {
        $result = self::getBlank($destString, $position);
        $result .= self::getToken($destString, $position, $breakValueList);
        return $result;
    }

    /**
     * 将字串转换为一种可显示的形式，比如回车字符以$0D的形式显示
     * @param string $value 需要显示的字符串
     * @return string
     */
    public static function displayString(string $value): string {
        $result = "";
        for ($i = 0; $i < StringFunc::length($value); $i++) {
            if (StringFunc::getCharCode(StringFunc::charAt($value, $i)) < 16) {
                $result .= "$0" . StringFunc::toUpper(dechex(StringFunc::getCharCode(StringFunc::charAt($value, $i))));
            } else if (StringFunc::getCharCode(StringFunc::charAt($value, $i)) < 20) {
                $result .= "$" . StringFunc::toUpper(dechex(StringFunc::getCharCode(StringFunc::charAt($value, $i))));
            } else $result .= StringFunc::charAt($value, $i);
        }
        return $result;
    }

}

/**
 * Class StringFunc 高级字符串函数(平台兼容函数)，第一个字符以0序号开始
 * @package TamPub1
 */
class StringFunc {
    /**
     * @var string 字符串编码格式
     */
    public static $encoding = "utf-8";

    /**
     * 获取指定位置的字符
     * @param string $value 源字符串
     * @param int $position 获取字符的位置
     * @return string 返回的字符，位置超界返回""
     */
    public static function charAt(string $value, int $position): string {
        if ($position < 0 || $position >= self::length($value)) {
            return "";
        } else {
            return mb_substr($value, $position, 1, self::$encoding);
        }
    }

    /**
     * 获取字符串的长度
     * @param string $value 字符串
     * @return int 字符串长度
     */
    public static function length(string $value): int {
        return mb_strlen($value, self::$encoding);
    }

    /**
     * 为保证代码兼容性封装的分割函数
     * @param string $value 被分割的字符串
     * @param string $seperator 分割标记
     * @return array
     */
    public static function split(string $value, string $seperator): array {
        return mb_split($seperator, $value);
    }

    /**
     * 获取一个字符的编码
     * @param string $char 字符串
     * @return int 编码
     */
    public static function getCharCode(string $char): int {
        return mb_ord($char, self::$encoding);
    }

    /**
     * 为保证代码兼容性封装的剪裁函数
     * @param string $value
     * @return string
     */
    public static function trim(string $value): string {
        return preg_replace('/(^\s+)|(\s+$)/u', '', $value);
    }

    /**
     * 为保证代码兼容性封装的转换大写函数
     * @param string $value
     * @return string
     */
    public static function toUpper(string $value): string {
        return mb_strtoupper($value, self::$encoding);
    }

    /**
     * 为保证代码兼容性封装的转换小写函数
     * @param string $value
     * @return string
     */
    public static function toLower(string $value): string {
        return mb_strtolower($value, self::$encoding);
    }

    /**
     * 为保证代码兼容性封装的字符串替换函数
     * @param string $value 原始字串
     * @param string $find 需要寻找的字串
     * @param string $newOne 需要替换的新的字串
     * @return string
     */
    public static function replace(string $value, string $find, string $newOne): string {
        return mb_ereg_replace($find, $newOne, $value);
    }

    /**
     * 取子字符串函数
     * @param string $value 源字符串
     * @param int $start 开始的位置
     * @param int $len 取值长度
     * @return string 返回值
     */
    public static function copy(string $value, int $start, int $len): string {
        if ($start < 0) {
            $len += $start;
            $start = 0;
        }
        if ($start + $len > self::length($value)) {
            $len -= $start + $len - self::length($value);
        }
        if ($len <= 0) {
            return "";
        } else {
            return mb_substr($value, $start, $len, self::$encoding);
        }
    }

    /**
     * 兼容Delphi的从1开始的搜索
     * @param string $subString 需要搜索的字串
     * @param string $value 被搜索的字串
     * @param int $startPos 起始搜索位置（从0开始）
     * @return int 大于等于0标识搜索到了，否则返回-1
     */
    public static function pos(string $subString, string $value, int $startPos): int {
        $pos = mb_strpos($value, $subString, $startPos, self::$encoding);
        return $pos ? $pos : -1;
    }

    /**
     * 在字符串末尾加一个字符，如果这个字符已经存在则不加
     * @param string $value
     * @param string $ch
     * @return string
     */
    public static function addRearChar(string $value, string $ch): string {
        if (self::length($value) <= 0) {
            return $ch;
        }
        if (self::copy($value, self::length($value) - 1, 1) === $ch) {
            return $value;
        } else {
            return $value . $ch;
        }
    }

    /**
     * 在字符串末尾删除一个字符，如果这个字符不存在则不删除任何字符
     * @param string $value
     * @param string $ch
     * @return string
     */
    public static function deleteRearChar(string $value, string $ch): string {
        if (self::length($value) <= 0) {
            return "";
        }
        if (self::copy($value, self::length($value) - 1, 1) === $ch) {
            return self::copy($value, 0, self::length($value) - 1);
        } else {
            return $value;
        }
    }

    /**
     * 在字符串前端增加一个字符，如果这个字符已经存在则不增加
     * @param string $value
     * @param string $ch
     * @return string
     */
    public static function addFrontChar(string $value, string $ch): string {
        if (self::length($value) <= 0) {
            return $ch;
        }
        if (self::copy($value, 0, 1) === $ch) {
            return $value;
        } else {
            return $ch . $value;
        }
    }

    /**
     * 在字符串前端删除一个字符，如果这个字符不存在则不做任何操作
     * @param string $value
     * @param string $ch
     * @return string
     */
    public static function deleteFrontChar(string $value, string $ch): string {
        if (self::length($value) <= 0) {
            return "";
        }
        if (self::copy($value, 0, 1) === $ch) {
            return self::copy($value, 1, self::length($value) - 1);
        } else {
            return $value;
        }
    }

    /**
     * 获取字元(第一个字符序号为0)
     * @param string $destString 需要分析的字符串
     * @param string $position 位置指针，以0为开始
     * @param string $breakValueList 结束标记字符列表
     * @return string token
     */
    public static function getToken(string $destString, string &$position, string $breakValueList): string {
        $result = "";
        for ($i = $position; $i < self::length($destString); $i++) {
            if (self::pos(self::charAt($destString, $i), $breakValueList, 0) >= 0) break;
            $result = $result . self::charAt($destString, $i);
        }
        $position = $i;
        return $result;
    }

    /**
     * 判断ch是否是英文字母
     * @param string $ch
     * @return bool
     */
    public static function isLetter(string $ch): bool {
        if ((strcmp($ch, 'a') >= 0) && (strcmp($ch, 'z') <= 0)) return true;
        if ((strcmp($ch, 'A') >= 0) && (strcmp($ch, 'Z') <= 0)) return true;
        return false;
    }

    /**
     * 判断一个字符是不是数字
     * @param string $ch
     * @return bool
     */
    public static function isNumber(string $ch): bool {
        if ((strcmp($ch, '0') >= 0) && (strcmp($ch, '9') <= 0)) return true;
        return false;
    }

    /**
     * 判断一个字符串是否是浮点数,不支持e的形式，用于替换缓慢的convert.toDouble判断形势
     * @param string $value
     * @return bool
     */
    public static function isFloat(string $value): bool {
        if (self::length($value) <= 0) return false;
        $dotCount = 0;
        for ($i = 0; $i < self::length($value); $i++) {
            if ($i == 0) {
                if (self::charAt($value, $i) === '+') continue;
                if (self::charAt($value, $i) === '-') continue;
            }
            if (self::isNumber(self::charAt($value, $i))) continue;
            if (self::charAt($value, $i) === '.') {
                $dotCount++;
                continue;
            }
            return false;
        }
        if ($dotCount > 1) {
            return false;
        } else return true;
    }

}

/**
 * 树结构
 * Class Tree
 * @package TamPub1
 */
class Tree {
    public $children = array();
    /**
     * @var Tree
     */
    public $parent;
    /**
     * @var Tree
     */
    public $value;
    /**
     * @var Tree
     */
    public $current;

    public function __construct() {
        $this->parent = null;
    }

    public function getFirst(): Tree {
        $current = $this;
        return $current;
    }

    /**
     * 以非递归形式实现的找下一个，当前节点存放在current中，仅凭current即可定位下一个节点位置
     * @return Tree
     */
    public function getNext(): Tree {
        if ($this->current == null) return null;
        //找最左边的子节点，找不到向下继续

        if (count($this->current->children) > 0) {
            $this->current = $this->current->children[0];
            return $this->current;
        }
        //是否是自身
        if ($this->current === $this) {
            $this->current = null;
            return null;
        }
        //找右邻的兄弟节点，找不到则返回父级继续找，如果父级等于自身则结束。
        while (true) {
            $node = self::getNextBrother($this->current);
            if ($node != null) {
                $this->current = $node;
                return $this->current;
            }
            if ($this->current->parent == null) {
                $this->current = null;
                return null;
            }
            $this->current = $this->current->parent;
            if ($this->current === $this) {
                //遍历结束
                $this->current = null;
                return null;
            }
        }
    }

    /**
     * 获取下一个同级的节点
     * @param $node Tree
     * @return null|string
     */
    public function getNextBrother(Tree $node): Tree {
        if ($node->parent == null) return null;
        for ($i = 0; $i < count($node->parent->children); $i++) {
            if ($node->parent->children[$i] === $node) {
                if ($i + 1 >= count($node->parent->children)) {
                    return null;
                } else {
                    return $node->parent->children[$i + 1];
                }
            }
        }
        return null;
    }

    public function addValue($value): Tree {
        return self::insertValue(count($this->children), $value);
    }

    public function addNode(Tree $node): Tree {
        return self::insertNode(count($this->children), $node);
    }

    public function insertNode(int $index, Tree $node): Tree {
        array_splice($this->children, $index, 0, $node);
        $node->parent = $this;
        return $node;
    }

    public function insertValue(int $index, $value): Tree {
        $item = new Tree();
        $item->value = $value;
        self::insertNode($index, $item);
        return $item;
    }

    public function addFirst($value): Tree {
        return self::insertValue(0, $value);
    }


    public function remove(Tree $node): bool {
        if ($node->parent == null) {
            return false;
        }
        return Etc::arrayDeleteObject($node->parent->children, $node);
    }

    public function clear() {
        $this->children = array();
        $this->current = null;
    }

    /**
     * 获取元素的数量（包含根节点）
     * @return int
     */
    public function getCount(): int {
        $result = 0;
        while (true) {
            if ($result == 0) {
                if (self::getFirst() == null) break;
            } else {
                if (self::getNext() == null) break;
            }
            $result++;
        }
        return $result;
    }
}

class Etc {
    /**
     * 删除数组中指定的对象
     * @param array $array 数组
     * @param object $object 需要删除的元素
     * @return bool 没找到返回false
     */
    public static function arrayDeleteObject(array $array, $object): bool {
        for ($i = 0; $i < count($array); $i++) {
            if ($array[$i] === $object) {
                array_splice($array, $i, 1);
                return true;
            }
        }
        return false;
    }


}

/**
 * 基于Xml格式的配置文件读写
 * Class ConfigFileXml
 * @package TamPub1
 */
class ConfigFileXml {
    public static $rootName = "root";

    private static function checkFile(string $filename): bool {
        if (file_exists($filename)) return true;
        $xml = new \SimpleXMLElement("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n" .
            "<" . self::$rootName . ">\r\n" .
            "</" . self::$rootName . ">\r\n"
        );
        $xml->asXml($filename);
        return true;
    }

    /**
     * 为兼容考虑，增加选节点函数，节点有重复的则选择第一个匹配的
     * @param \SimpleXMLElement $xmlDoc 载入缓存的xml文档
     * @param string $path 路径信息，不包含root，如: /field1/field2
     * @return \SimpleXMLElement
     */
    private static function selectSingleNode(\SimpleXMLElement $xmlDoc, string $path) {
        $path = StringFunc::addFrontChar($path, '/');
        $nodes = $xmlDoc->xpath($path);
        if (count($nodes) <= 0) return null;
        return $nodes[0];
    }

    /**
     * 检测并创建Key
     * @param string $filename
     * @param string $key 形式如: key1/key2/key3
     * @return int -1:error; 0:success; 1:newkey
     */
    public static function checkKey(string $filename, string $key): int {
        $xml = simplexml_load_file($filename);
        if (!$xml) return -1; //can not load xml file
        //System . Xml . XmlNode node = null;
        $nodes = $xml->xpath("/" . self::$rootName);
        if (count($nodes) <= 0) return -1;
        $lastNode = $nodes[0];
        //System . Xml . XmlElement newNode = null;
        $sp = 0;
        $result = 0;
        while (true) {
            if ($sp >= StringFunc::length($key)) break;
            $sp1 = StringFunc::pos('/', $key, $sp);
            if ($sp1 < 0) {
                $sp1 = StringFunc::length($key);
            }
            $nodeName = StringFunc::copy($key, $sp, $sp1 - $sp);
            $node = self::selectSingleNode($xml, self::$rootName . "/" . StringFunc::copy($key, 0, $sp1));
            if ($node == null) {
                $newNode = $lastNode->addChild($nodeName);
                $node = $newNode;
                $result = 1;
            }
            $lastNode = $node;
            $sp = $sp1 + 1;
        }
        $xml->asXml($filename);
        return $result;
    }

    /**
     * 按照路径创建节点，如果节点已经存在则不创建
     * @param \SimpleXMLElement $xmlDoc
     * @param string $path
     * @return \SimpleXMLElement -1:error; 0:success; 1:newkey
     */
    public static function createPath(\SimpleXMLElement $xmlDoc, string $path): \SimpleXMLElement {
        $node = null;
        $lastNode = null;
        $path = StringFunc::deleteFrontChar($path, '/');
        $path = StringFunc::deleteRearChar($path, '/');
        $p = StringFunc::split($path, '/');
        if (count($p) <= 0) return null;
        $path = "";
        for ($i = 0; $i < count($p); $i++) {
            $path .= "/" . $p[$i];
            $node = self::selectSingleNode($xmlDoc, $path);
            if ($node == null) {
                if ($lastNode == null) {
                    $node = $xmlDoc->addChild($p[$i]);
                } else {
                    $node = $lastNode->addChild($p[$i]);
                }
            }
            $lastNode = $node;
        }
        return $node;
    }

    public static function writeString(string $filename, string $key, string $value): bool {
        if (!self::checkFile($filename)) return false;
        if (self::checkKey($filename, $key) < 0) return false;
        $xmlDoc = simplexml_load_file($filename);
        $node = self::selectSingleNode($xmlDoc, self::$rootName . "/" . $key);
        if ($node == null) return false;
        $node[0] = $value;
        $xmlDoc->asXML($filename);
        return true;
    }

    public static function writeStringAttr(string $filename, string $key, string $subKey, string $value): bool {
        if (!self::checkFile($filename)) return false;
        if (self::checkKey($filename, $key) < 0) return false;
        $xmlDoc = simplexml_load_file($filename);
        $node = self::selectSingleNode($xmlDoc, self::$rootName . "/" . $key);
        if ($node == null) return false;
        if (!$node->attributes()->$subKey) {
            $node->addAttribute($subKey, $value);
        } else {
            $node->attributes()->$subKey = $value;
        }
        $xmlDoc->asXML($filename);
        return true;
    }

    public static function writeInt(string $filename, string $key, int $value): bool {
        return self::writeString($filename, $key, $value);
    }

    public static function writeIntAttr(string $filename, string $key, string $subKey, int $value): bool {
        return self::writeStringAttr($filename, $key, $subKey, $value);
    }

    public static function readString(string $filename, string $key, string $defaultValue): string {
        if (!self::checkFile($filename)) return $defaultValue;
        $ckResult = self::checkKey($filename, $key);
        if ($ckResult < 0) return $defaultValue;
        $xmlDoc = simplexml_load_file($filename);
        $node = self::selectSingleNode($xmlDoc, self::$rootName . "/" . $key);
        if ($node == null) return "";
        if ($ckResult == 1) $node[0] = $defaultValue;
        $result = $node[0];
        $xmlDoc->asXML($filename);
        return $result;
    }

    public static function readStringAttr(string $filename, string $key, string $subKey, string $defaultValue): string {
        if (!self::checkFile($filename)) return $defaultValue;
        if (self::checkKey($filename, $key) < 0) return $defaultValue;
        $xmlDoc = simplexml_load_file($filename);
        $node = self::selectSingleNode($xmlDoc, self::$rootName . "/" . $key);
        $result = self::readStringAttrFromNode($node, $subKey, $defaultValue);
        $xmlDoc->asXML($filename);
        return $result;
    }

    public static function readInt(string $filename, string $key, int $defaultValue): int {
        return (int)self::readString($filename, $key, $defaultValue);
    }

    public static function readIntAttr(string $filename, string $key, string $subKey, int $defaultValue): int {
        return (int)self::readStringAttr($filename, $key, $subKey, $defaultValue);
    }

    /**
     * 自动创建项目（如果项目不存在的话）
     * @param \SimpleXMLElement $doc
     * @param string $key
     * @return \SimpleXMLElement
     */
    public static function create(\SimpleXMLElement $doc, string $key): \SimpleXMLElement {
        $node = null;
        $key = StringFunc::deleteFrontChar($key, '/');
        $key = StringFunc::deleteRearChar($key, '/');
        $s = StringFunc::split('/', $key);
        for ($i = 0; $i < count($s); $i++) {
            $path = "";
            for ($j = 0; $j <= $i; $j++) {
                $path = $path . '/' . $s[$j];
            }
            if (self::selectSingleNode($doc, $path) != null) {
                $node = self::selectSingleNode($doc, $path);
                continue;
            }
            if ($i == 0) {
                $node = $doc->addChild($s[$i]);
            } else {
                $node = $node->addChild($s[$i]);
            }
        }
        return $node;
    }

    /**
     * 在node下创建一个子节点，子节名字允许重复
     * @param \SimpleXMLElement $doc
     * @param \SimpleXMLElement $node
     * @param string $key
     * @return \SimpleXMLElement
     */
    public static function createFromNode(\SimpleXMLElement $doc, \SimpleXMLElement $node, string $key): \SimpleXMLElement {
        return $node->addChild($key);
    }

    public static function readStringFromNode(\SimpleXMLElement $node, string $defaultValue): string {
        if ($node == null) return "";
        if (StringFunc::copy($node[0], 0, StringFunc::length("<![CDATA[")) === "<![CDATA[") {
            $result = StringFunc::replace($node[0], "&amp;", "&");
        } else {
            $result = $node[0];
        }
        return $result;
    }

    public static function readStringAttrFromNode(\SimpleXMLElement $node, string $subKey, string $defaultValue): string {
        if ($node == null) return "";
        if (!$node->attributes()->$subKey) {
            $node->addAttribute($subKey, $defaultValue);
        }
        return $node->attributes()->$subKey;
    }

    public static function writeStringFromNode(\SimpleXMLElement $node, string $value): bool {
        if ($node == null) return false;
        $node[0] = $value;
        return true;
    }

    public static function writeStringAttrFromNode(\SimpleXMLElement $node, string $subKey, string $value): bool {
        if ($node == null) return false;
        $node->$subKey = $value;
        return true;
    }

    public static function readIntFromNode(\SimpleXMLElement $node, int $defaultValue): int {
        return (int)self::readStringFromNode($node, $defaultValue);
    }

    public static function readIntAttrFromNode(\SimpleXMLElement $node, string $subKey, int $defaultValue): int {
        return (int)self::readStringAttrFromNode($node, $subKey, $defaultValue);
    }

    public static function writeIntFromNode(\SimpleXMLElement $node, int $value): bool {
        return self::writeStringFromNode($node, $value);
    }

    public static function writeIntAttrFromNode(\SimpleXMLElement $node, string $subKey, int $value): bool {
        return self::writeStringAttrFromNode($node, $subKey, $value);
    }


}

















