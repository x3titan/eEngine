<?php
/**
 * Created by PhpStorm.
 * User: Jesse Tam
 * Date: 2019/6/2 0002
 * Time: 下午 6:22
 */

namespace TamPub1;

class DelphiString {
    public static $encoding = "utf-8";

    /**
     * 兼容Delphi的从1开始的copy
     * @param string $value 需要拷贝的字串
     * @param int $startPos 从1开始的起始位置
     * @param int $len 需要拷贝的长度
     * @return string 子字符串
     */
    public static function copy(string $value, int $startPos, int $len): string {
        return StringFunc::copy($value, $startPos - 1, $len);
    }

    /**
     * 兼容Delphi的从1开始的搜索
     * @param string $subString 需要搜索的字串
     * @param string $value 被搜索的字串
     * @param int $startPos 起始搜索位置（从1开始）
     * @return int 大于等于1标识搜索到了，否则返回0
     */
    public static function pos(string $subString, string $value, int $startPos): int {
        return StringFunc::pos($subString, $value, $startPos - 1) + 1;
    }

    /**
     * 获取字元
     * @param string $destString 需要分析的字符串
     * @param int $position 位置指针
     * @param string $breakValueList 结束标记字符列表
     * @return string token
     */
    public static function getToken(string $destString, int &$position, string $breakValueList): string {
        $result = "";
        for ($i = $position - 1; $i < StringFunc::length($destString); $i++) {
            if (self::pos(StringFunc::charAt($destString, $i), $breakValueList, 1) > 0) break;
            $result = $result . StringFunc::charAt($destString, $i);
        }
        $position = $i + 1;
        return $result;
    }

    public static function getBlank(string $destString, int &$position): string {
        $result = "";
        for ($i = $position - 1; $i < StringFunc::length($destString); $i++) {
            if (StringFunc::getCharCode(StringFunc::charAt($destString, $i)) > 0x20) break;
            $result .= StringFunc::charAt($destString, $i);
        }
        $position = $i + 1;
        return $result;
    }

    public static function getBlankAndToken(string $destString, int &$position, string $breakValueList): string {
        $result = self::getBlank($destString, $position);
        $result .= self::getToken($destString, $position, $breakValueList);
        return $result;
    }

    /**
     * 将字串转换为一种可显示的形式，比如回车字符以$0D的形式显示
     * @param string $value 需要显示的字符串
     * @return string
     */
    public static function displayString(string $value): string {
        $result = "";
        for ($i = 0; $i < StringFunc::length($value); $i++) {
            if (StringFunc::getCharCode(StringFunc::charAt($value, $i)) < 16) {
                $result .= "$0" . StringFunc::toUpper(dechex(StringFunc::getCharCode(StringFunc::charAt($value, $i))));
            } else if (StringFunc::getCharCode(StringFunc::charAt($value, $i)) < 20) {
                $result .= "$" . StringFunc::toUpper(dechex(StringFunc::getCharCode(StringFunc::charAt($value, $i))));
            } else $result .= StringFunc::charAt($value, $i);
        }
        return $result;
    }

}

/**
 * Class StringFunc 高级字符串函数(平台兼容函数)，第一个字符以0序号开始
 * @package TamPub1
 */
class StringFunc {
    /**
     * @var string 字符串编码格式
     */
    public static $encoding = "utf-8";

    /**
     * 获取指定位置的字符
     * @param string $value 源字符串
     * @param int $position 获取字符的位置
     * @return string 返回的字符，位置超界返回""
     */
    public static function charAt(string $value, int $position): string {
        if ($position < 0 || $position >= self::length($value)) {
            return "";
        } else {
            return mb_substr($value, $position, 1, self::$encoding);
        }
    }

    /**
     * 获取字符串的长度
     * @param string $value 字符串
     * @return int 字符串长度
     */
    public static function length(string $value): int {
        return mb_strlen($value, self::$encoding);
    }

    /**
     * 为保证代码兼容性封装的分割函数
     * @param string $value 被分割的字符串
     * @param string $seperator 分割标记
     * @return array
     */
    public static function split(string $value, string $seperator): array {
        return mb_split($seperator, $value);
    }

    /**
     * 获取一个字符的编码
     * @param string $char 字符串
     * @return int 编码
     */
    public static function getCharCode(string $char): int {
        return mb_ord($char, self::$encoding);
    }

    /**
     * 为保证代码兼容性封装的剪裁函数
     * @param string $value
     * @return string
     */
    public static function trim(string $value): string {
        return preg_replace('/(^\s+)|(\s+$)/u', '', $value);
    }

    /**
     * 为保证代码兼容性封装的转换大写函数
     * @param string $value
     * @return string
     */
    public static function toUpper(string $value): string {
        return mb_strtoupper($value, self::$encoding);
    }

    /**
     * 为保证代码兼容性封装的转换小写函数
     * @param string $value
     * @return string
     */
    public static function toLower(string $value): string {
        return mb_strtolower($value, self::$encoding);
    }

    /**
     * 为保证代码兼容性封装的字符串替换函数
     * @param string $value 原始字串
     * @param string $find 需要寻找的字串
     * @param string $newOne 需要替换的新的字串
     * @return string
     */
    public static function replace(string $value, string $find, string $newOne): string {
        if ($value==="") return "";
        return mb_ereg_replace($find, $newOne, $value);
    }

    /**
     * 取子字符串函数
     * @param string $value 源字符串
     * @param int $start 开始的位置
     * @param int $len 取值长度
     * @return string 返回值
     */
    public static function copy(string $value, int $start, int $len): string {
        if ($start < 0) {
            $len += $start;
            $start = 0;
        }
        if ($start + $len > self::length($value)) {
            $len -= $start + $len - self::length($value);
        }
        if ($len <= 0) {
            return "";
        } else {
            return mb_substr($value, $start, $len, self::$encoding);
        }
    }

    /**
     * 比较两个字串的大小
     * @param string $value1 第一个字符串
     * @param string $value2 第二个字符串
     * @param bool $caseSensitive 是否大小写敏感
     * @return int 第一个值小于等于大于，分别返回-1,0,1
     */
    public static function compare(string $value1, string $value2, bool $caseSensitive = true): int {
        if ($caseSensitive) {
            return strcmp($value1, $value2);
        } else {
            return strcasecmp($value1, $value2);
        }
    }

    /**
     * 从0开始的搜索
     * @param string $subString 需要搜索的字串
     * @param string $value 被搜索的字串
     * @param int $startPos 起始搜索位置（从0开始）
     * @return int 大于等于0标识搜索到了，否则返回-1
     */
    public static function pos(string $subString, string $value, int $startPos = 0): int {
        $pos = mb_strpos($value, $subString, $startPos, self::$encoding);
        return $pos ? $pos : -1;
    }

    /**
     * 从0开始的搜索
     * @param string $value 字串
     * @param string $find 需要查找的片段
     * @param int $startPos 起始搜索位置（从0开始）
     * @return int 大于等于0标识搜索到了，否则返回-1
     */
    public static function indexOf(string $value, string $find, int $startPos = 0): int {
        return self::pos($find, $value, $startPos);
    }

    /**
     * 逆向查找$find首次出现的位置
     * @param string $value 母字串
     * @param string $find 需要查找的内容
     * @param int $startPos 开始查找的位置，首字母为0，最后一个字母为-1，默认-1
     * @param bool $caseSensitive 是否大小写敏感，默认敏感
     * @return int 出现的位置，没找到返回-1
     */
    public static function lastIndexOf(string $value, string $find, int $startPos = -1, bool $caseSensitive = true): int {
        if ($startPos < 0) $startPos = self::length($value) + $startPos;
        $findLen = self::length($find);
        if (!$caseSensitive) {
            $find = self::toUpper($find);
            $value = self::toUpper($value);
        }
        for ($i = min($startPos, self::length($value) - $findLen); $i >= 0; $i--) {
            if (self::copy($value, $i, $findLen) === $find) return $i;
        }
        return -1;
    }

    /**
     * 在字符串末尾加一个字符，如果这个字符已经存在则不加
     * @param string $value
     * @param string $ch
     * @return string
     */
    public static function addRearChar(string $value, string $ch): string {
        if (self::length($value) <= 0) {
            return $ch;
        }
        if (self::copy($value, self::length($value) - 1, 1) === $ch) {
            return $value;
        } else {
            return $value . $ch;
        }
    }

    /**
     * 在字符串末尾删除一个字符，如果这个字符不存在则不删除任何字符
     * @param string $value
     * @param string $ch
     * @return string
     */
    public static function deleteRearChar(string $value, string $ch): string {
        if (self::length($value) <= 0) {
            return "";
        }
        if (self::copy($value, self::length($value) - 1, 1) === $ch) {
            return self::copy($value, 0, self::length($value) - 1);
        } else {
            return $value;
        }
    }

    /**
     * 在字符串前端增加一个字符，如果这个字符已经存在则不增加
     * @param string $value
     * @param string $ch
     * @return string
     */
    public static function addFrontChar(string $value, string $ch): string {
        if (self::length($value) <= 0) {
            return $ch;
        }
        if (self::copy($value, 0, 1) === $ch) {
            return $value;
        } else {
            return $ch . $value;
        }
    }

    /**
     * 在字符串前端删除一个字符，如果这个字符不存在则不做任何操作
     * @param string $value
     * @param string $ch
     * @return string
     */
    public static function deleteFrontChar(string $value, string $ch): string {
        if (self::length($value) <= 0) {
            return "";
        }
        if (self::copy($value, 0, 1) === $ch) {
            return self::copy($value, 1, self::length($value) - 1);
        } else {
            return $value;
        }
    }

    /**
     * 获取字元(第一个字符序号为0)
     * @param string $destString 需要分析的字符串
     * @param string $position 位置指针，以0为开始
     * @param string $breakValueList 结束标记字符列表
     * @return string token
     */
    public static function getToken(string $destString, string &$position, string $breakValueList): string {
        $result = "";
        for ($i = $position; $i < self::length($destString); $i++) {
            if (self::pos(self::charAt($destString, $i), $breakValueList, 0) >= 0) break;
            $result = $result . self::charAt($destString, $i);
        }
        $position = $i;
        return $result;
    }

    /**
     * 判断ch是否是英文字母
     * @param string $ch
     * @return bool
     */
    public static function isLetter(string $ch): bool {
        if ((strcmp($ch, 'a') >= 0) && (strcmp($ch, 'z') <= 0)) return true;
        if ((strcmp($ch, 'A') >= 0) && (strcmp($ch, 'Z') <= 0)) return true;
        return false;
    }

    /**
     * 判断一个字符是不是数字
     * @param string $ch
     * @return bool
     */
    public static function isNumber(string $ch): bool {
        if ((strcmp($ch, '0') >= 0) && (strcmp($ch, '9') <= 0)) return true;
        return false;
    }

    /**
     * （兼容性）判断一个字符串是不是整数
     * @param string $value
     * @return bool
     */
    public static function isInt(string $value): bool {
        return is_numeric($value) && !strpos($value, '.');
    }

    /**
     * 判断一个字符串是否是浮点数,不支持e的形式，用于替换缓慢的convert.toDouble判断形势
     * @param string $value
     * @return bool
     */
    public static function isFloat(string $value): bool {
        if (self::length($value) <= 0) return false;
        $dotCount = 0;
        for ($i = 0; $i < self::length($value); $i++) {
            if ($i == 0) {
                if (self::charAt($value, $i) === '+') continue;
                if (self::charAt($value, $i) === '-') continue;
            }
            if (self::isNumber(self::charAt($value, $i))) continue;
            if (self::charAt($value, $i) === '.') {
                $dotCount++;
                continue;
            }
            return false;
        }
        if ($dotCount > 1) {
            return false;
        } else return true;
    }

}

/**
 * 树结构
 * Class Tree
 * @package TamPub1
 */
class Tree {
    public $children = array();
    /**
     * @var Tree
     */
    public $parent;
    /**
     * @var Tree
     */
    public $value;
    /**
     * @var Tree
     */
    public $current;

    public function __construct() {
        $this->parent = null;
    }

    public function getFirst(): Tree {
        $this->current = $this;
        return $this->current;
    }

    /**
     * 以非递归形式实现的找下一个，当前节点存放在current中，仅凭current即可定位下一个节点位置
     * @return Tree
     */
    public function getNext(): ? Tree {
        if ($this->current == null) return null;
        //找最左边的子节点，找不到向下继续

        if (count($this->current->children) > 0) {
            $this->current = $this->current->children[0];
            return $this->current;
        }
        //是否是自身
        if ($this->current === $this) {
            $this->current = null;
            return null;
        }
        //找右邻的兄弟节点，找不到则返回父级继续找，如果父级等于自身则结束。
        while (true) {
            $node = self::getNextBrother($this->current);
            if ($node != null) {
                $this->current = $node;
                return $this->current;
            }
            if ($this->current->parent == null) {
                $this->current = null;
                return null;
            }
            $this->current = $this->current->parent;
            if ($this->current === $this) {
                //遍历结束
                $this->current = null;
                return null;
            }
        }
        return null; //no use
    }

    /**
     * 获取下一个同级的节点
     * @param $node Tree
     * @return null|string
     */
    public function getNextBrother(Tree $node): ? Tree {
        if ($node->parent == null) return null;
        for ($i = 0; $i < count($node->parent->children); $i++) {
            if ($node->parent->children[$i] === $node) {
                if ($i + 1 >= count($node->parent->children)) {
                    return null;
                } else {
                    return $node->parent->children[$i + 1];
                }
            }
        }
        return null;
    }

    public function addValue($value): Tree {
        return self::insertValue(count($this->children), $value);
    }

    public function addNode(Tree $node): Tree {
        return self::insertNode(count($this->children), $node);
    }

    public function insertNode(int $index, Tree $node): Tree {
        array_splice($this->children, $index, 0, [$node]);
        $node->parent = $this;
        return $node;
    }

    public function insertValue(int $index, $value): Tree {
        $item = new Tree();
        $item->value = $value;
        self::insertNode($index, $item);
        return $item;
    }

    public function addFirst($value): Tree {
        return self::insertValue(0, $value);
    }


    public function remove(Tree $node): bool {
        if ($node->parent == null) {
            return false;
        }
        return Etc::arrayDeleteObject($node->parent->children, $node);
    }

    public function clear() {
        $this->children = array();
        $this->current = null;
    }

    /**
     * 获取元素的数量（包含根节点）
     * @return int
     */
    public function getCount(): int {
        $result = 0;
        while (true) {
            if ($result == 0) {
                if (self::getFirst() == null) break;
            } else {
                if (self::getNext() == null) break;
            }
            $result++;
        }
        return $result;
    }
}

class Etc {
    /**
     * 删除数组中指定的对象
     * @param array $array 数组
     * @param object $object 需要删除的元素
     * @return bool 没找到返回false
     */
    public static function arrayDeleteObject(array $array, $object): bool {
        for ($i = 0; $i < count($array); $i++) {
            if ($array[$i] === $object) {
                array_splice($array, $i, 1);
                return true;
            }
        }
        return false;
    }


}

/**
 * 基于Xml格式的配置文件读写
 * Class ConfigFileXml
 * @package TamPub1
 */
class ConfigFileXml {
    public static $rootName = "root";

    private static function checkFile(string $filename): bool {
        if (file_exists($filename)) return true;
        $xml = new \SimpleXMLElement("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n" .
            "<" . self::$rootName . ">\r\n" .
            "</" . self::$rootName . ">\r\n"
        );
        $xml->asXml($filename);
        return true;
    }

    /**
     * 为兼容考虑，增加选节点函数，节点有重复的则选择第一个匹配的
     * @param \SimpleXMLElement $xmlDoc 载入缓存的xml文档
     * @param string $path 路径信息，不包含root，如: /field1/field2
     * @return \SimpleXMLElement
     */
    private static function selectSingleNode(\SimpleXMLElement $xmlDoc, string $path): ? \SimpleXMLElement {
        $path = StringFunc::addFrontChar($path, '/');
        $nodes = $xmlDoc->xpath($path);
        if (count($nodes) <= 0) return null;
        return $nodes[0];
    }

    /**
     * 检测并创建Key
     * @param string $filename
     * @param string $key 形式如: key1/key2/key3
     * @return int -1:error; 0:success; 1:newkey
     */
    public static function checkKey(string $filename, string $key): int {
        $xml = simplexml_load_file($filename);
        if (!$xml) return -1; //can not load xml file
        //System . Xml . XmlNode node = null;
        $nodes = $xml->xpath("/" . self::$rootName);
        if (count($nodes) <= 0) return -1;
        $lastNode = $nodes[0];
        //System . Xml . XmlElement newNode = null;
        $sp = 0;
        $result = 0;
        while (true) {
            if ($sp >= StringFunc::length($key)) break;
            $sp1 = StringFunc::pos('/', $key, $sp);
            if ($sp1 < 0) {
                $sp1 = StringFunc::length($key);
            }
            $nodeName = StringFunc::copy($key, $sp, $sp1 - $sp);
            $node = self::selectSingleNode($xml, self::$rootName . "/" . StringFunc::copy($key, 0, $sp1));
            if ($node == null) {
                $newNode = $lastNode->addChild($nodeName);
                $node = $newNode;
                $result = 1;
            }
            $lastNode = $node;
            $sp = $sp1 + 1;
        }
        $xml->asXml($filename);
        return $result;
    }

    /**
     * 按照路径创建节点，如果节点已经存在则不创建
     * @param \SimpleXMLElement $xmlDoc
     * @param string $path
     * @return \SimpleXMLElement -1:error; 0:success; 1:newkey
     */
    public static function createPath(\SimpleXMLElement $xmlDoc, string $path): \SimpleXMLElement {
        $node = null;
        $lastNode = null;
        $path = StringFunc::deleteFrontChar($path, '/');
        $path = StringFunc::deleteRearChar($path, '/');
        $p = StringFunc::split($path, '/');
        if (count($p) <= 0) return null;
        $path = "";
        for ($i = 0; $i < count($p); $i++) {
            $path .= "/" . $p[$i];
            $node = self::selectSingleNode($xmlDoc, $path);
            if ($node == null) {
                if ($lastNode == null) {
                    $node = $xmlDoc->addChild($p[$i]);
                } else {
                    $node = $lastNode->addChild($p[$i]);
                }
            }
            $lastNode = $node;
        }
        return $node;
    }

    public static function writeString(string $filename, string $key, string $value): bool {
        if (!self::checkFile($filename)) return false;
        if (self::checkKey($filename, $key) < 0) return false;
        $xmlDoc = simplexml_load_file($filename);
        $node = self::selectSingleNode($xmlDoc, self::$rootName . "/" . $key);
        if ($node == null) return false;
        $node[0] = $value;
        $xmlDoc->asXML($filename);
        return true;
    }

    public static function writeStringAttr(string $filename, string $key, string $subKey, string $value): bool {
        if (!self::checkFile($filename)) return false;
        if (self::checkKey($filename, $key) < 0) return false;
        $xmlDoc = simplexml_load_file($filename);
        $node = self::selectSingleNode($xmlDoc, self::$rootName . "/" . $key);
        if ($node == null) return false;
        if (!$node->attributes()->$subKey) {
            $node->addAttribute($subKey, $value);
        } else {
            $node->attributes()->$subKey = $value;
        }
        $xmlDoc->asXML($filename);
        return true;
    }

    public static function writeInt(string $filename, string $key, int $value): bool {
        return self::writeString($filename, $key, $value);
    }

    public static function writeIntAttr(string $filename, string $key, string $subKey, int $value): bool {
        return self::writeStringAttr($filename, $key, $subKey, $value);
    }

    public static function readString(string $filename, string $key, string $defaultValue): string {
        if (!self::checkFile($filename)) return $defaultValue;
        $ckResult = self::checkKey($filename, $key);
        if ($ckResult < 0) return $defaultValue;
        $xmlDoc = simplexml_load_file($filename);
        $node = self::selectSingleNode($xmlDoc, self::$rootName . "/" . $key);
        if ($node == null) return "";
        if ($ckResult == 1) $node[0] = $defaultValue;
        $result = $node[0];
        $xmlDoc->asXML($filename);
        return $result;
    }

    public static function readStringAttr(string $filename, string $key, string $subKey, string $defaultValue): string {
        if (!self::checkFile($filename)) return $defaultValue;
        if (self::checkKey($filename, $key) < 0) return $defaultValue;
        $xmlDoc = simplexml_load_file($filename);
        $node = self::selectSingleNode($xmlDoc, self::$rootName . "/" . $key);
        $result = self::readStringAttrFromNode($node, $subKey, $defaultValue);
        $xmlDoc->asXML($filename);
        return $result;
    }

    public static function readInt(string $filename, string $key, int $defaultValue): int {
        return (int)self::readString($filename, $key, $defaultValue);
    }

    public static function readIntAttr(string $filename, string $key, string $subKey, int $defaultValue): int {
        return (int)self::readStringAttr($filename, $key, $subKey, $defaultValue);
    }

    /**
     * 自动创建项目（如果项目不存在的话）
     * @param \SimpleXMLElement $doc
     * @param string $key
     * @return \SimpleXMLElement
     */
    public static function create(\SimpleXMLElement $doc, string $key): \SimpleXMLElement {
        $node = null;
        $key = StringFunc::deleteFrontChar($key, '/');
        $key = StringFunc::deleteRearChar($key, '/');
        $s = StringFunc::split($key, '/');
        for ($i = 0; $i < count($s); $i++) {
            $path = "";
            for ($j = 0; $j <= $i; $j++) {
                $path = $path . '/' . $s[$j];
            }
            if (self::selectSingleNode($doc, $path) != null) {
                $node = self::selectSingleNode($doc, $path);
                continue;
            }
            if ($i == 0) {
                $node = $doc->addChild($s[$i]);
            } else {
                $node = $node->addChild($s[$i]);
            }
        }
        return $node;
    }

    /**
     * 在node下创建一个子节点，子节名字允许重复
     * @param \SimpleXMLElement $doc
     * @param \SimpleXMLElement $node
     * @param string $key
     * @return \SimpleXMLElement
     */
    public static function createFromNode(\SimpleXMLElement $doc, \SimpleXMLElement $node, string $key): \SimpleXMLElement {
        return $node->addChild($key);
    }

    public static function readStringFromNode(\SimpleXMLElement $node, string $defaultValue): string {
        if ($node == null) return "";
        if (StringFunc::copy($node[0], 0, StringFunc::length("<![CDATA[")) === "<![CDATA[") {
            $result = StringFunc::replace($node[0], "&amp;", "&");
        } else {
            $result = $node[0];
        }
        return $result;
    }

    public static function readStringAttrFromNode(\SimpleXMLElement $node, string $subKey, string $defaultValue): string {
        if ($node == null) return "";
        if (!$node->attributes()->$subKey) {
            $node->addAttribute($subKey, $defaultValue);
        }
        return $node->attributes()->$subKey;
    }

    public static function writeStringFromNode(\SimpleXMLElement $node, string $value): bool {
        if ($node == null) return false;
        $node[0] = $value;
        return true;
    }

    public static function writeStringAttrFromNode(\SimpleXMLElement $node, string $subKey, string $value): bool {
        if ($node == null) return false;
        $node->$subKey = $value;
        return true;
    }

    public static function readIntFromNode(\SimpleXMLElement $node, int $defaultValue): int {
        return (int)self::readStringFromNode($node, $defaultValue);
    }

    public static function readIntAttrFromNode(\SimpleXMLElement $node, string $subKey, int $defaultValue): int {
        return (int)self::readStringAttrFromNode($node, $subKey, $defaultValue);
    }

    public static function writeIntFromNode(\SimpleXMLElement $node, int $value): bool {
        return self::writeStringFromNode($node, $value);
    }

    public static function writeIntAttrFromNode(\SimpleXMLElement $node, string $subKey, int $value): bool {
        return self::writeStringAttrFromNode($node, $subKey, $value);
    }

    public static function readHexFromNode(\SimpleXMLElement $node, int $defaultValue): int {
        return hexdec(self::readStringFromNode($node, dechex($defaultValue)));
    }

    public static function readHexAttrFromNode(\SimpleXMLElement $node, string $subKey, int $defaultValue) {
        return hexdec(self::readStringAttrFromNode($node, $subKey, dechex($defaultValue)));
    }

    public static function writeHexFromNode(\SimpleXMLElement $node, int $value): bool {
        return self::writeStringFromNode($node, dechex($value));
    }

    public static function writeHexAttrFromNode(\SimpleXMLElement $node, string $subKey, int $value): bool {
        return self::writeStringAttrFromNode($node, $subKey, dechex($value));
    }

    public static function appendAttr(\SimpleXMLElement $doc, \SimpleXMLElement $node, string $key, string $value): void {
        $node->addAttribute($key, $value);
    }

    /**
     * 把一个普通字串转换为CData形式的数据
     * @param string $value
     * @return string
     */
    public static function getCData(string $value): string {
        return "<![CDATA[" . StringFunc::replace($value, "]]>", "]]]]><![CDATA[>") . "]]>";
    }

    public static function getCDataText(string $value): string {
        return self::getCData(StringFunc::replace(StringFunc::replace($value, "\r\n", "\n"), "\n", "\r\n"));
    }

    /**
     * 自动判断是否有产生CData形式数据的必要
     * @param string $value
     * @return string
     */
    public static function getDDataTextAuto(string $value): string {
        $value = StringFunc::replace($value, "&", "&amp;");
        if (StringFunc::pos('<', $value) >= 0) {
            return self::getCDataText($value);
        } else if (StringFunc::pos('>', $value) >= 0) {
            return self::getCDataText($value);
        } else {
            return $value;
        }
    }
}

/**
 * Class ConverterBin binary stream converter vs basic type such as int string bool etc.
 * @package TamPub1
 */
class Converter {
    /**
     * convert integer(32bit) to binary
     * @param int $value
     * @return string
     */
    public static function int32ToBin(int $value): string {
        return
            chr($value & 0x000000FF) .
            chr(($value & 0x0000FF00) >> 8) .
            chr(($value & 0x00FF0000) >> 16) .
            chr(($value & 0xFF000000) >> 24);
    }

    /**
     * convert 4 bytes binary to integer(32bit)
     * @param string $value
     * @return int
     */
    public static function binToInt32(string $value): int {
        if (strlen($value) < 4) return 0;
        $result =
            ord($value[0]) |
            ord($value[1]) << 8 |
            ord($value[2]) << 16 |
            ord($value[3]) << 24;
        if ((ord($value[3]) & 0x80) > 0) {
            $result = $result | 0xFFFFFFFF << 32;
        }
        return $result;
    }

    /**
     * convert unsigned integer(32bit)(dword) to binary
     * @param int $value
     * @return string
     */
    public static function uint32ToBin(int $value): string {
        return self::int32ToBin($value);
    }

    /**
     * convert 4 bytes binary to unsigned integer(32bit)(dword)
     * @param string $value
     * @return int
     */
    public static function binToUInt32(string $value): int {
        if (strlen($value) < 4) return 0;
        return
            ord($value[0]) |
            ord($value[1]) << 8 |
            ord($value[2]) << 16 |
            ord($value[3]) << 24;
    }

    /**
     * convert integer(16bit) to binary
     * @param int $value
     * @return string
     */
    public static function int16ToBin(int $value): string {
        return
            chr($value & 0x000000FF) .
            chr(($value & 0x0000FF00) >> 8);
    }

    /**
     * convert 2 bytes binary to integer(16bit)
     * @param string $value
     * @return int
     */
    public static function binToInt16(string $value): int {
        if (strlen($value) < 2) return 0;
        $result =
            ord($value[0]) |
            ord($value[1]) << 8;
        if ((ord($value[1]) & 0x80) > 0) {
            $result = $result | 0xFFFFFFFFFFFF << 16;
        }
        return $result;
    }

    /**
     * convert unsigned integer(16bit)(word) to binary
     * @param int $value
     * @return string
     */
    public static function uint16ToBin(int $value): string {
        return self::int16ToBin($value);
    }

    /**
     * convert 2 bytes binary to unsigned integer(16bit)(word)
     * @param string $value
     * @return int
     */
    public static function binToUInt16(string $value): int {
        if (strlen($value) < 2) return 0;
        return
            ord($value[0]) |
            ord($value[1]) << 8;
    }

    /**
     * convert integer(8bit) to binary
     * @param int $value
     * @return string
     */
    public static function int8ToBin(int $value): string {
        return chr($value & 0x000000FF);
    }

    /**
     * convert 1 bytes binary to integer(8bit)
     * @param string $value
     * @return int
     */
    public static function binToInt8(string $value): int {
        if (strlen($value) < 1) return 0;
        $result = ord($value[0]);
        if ((ord($value[0]) & 0x80) > 0) {
            $result = $result | 0xFFFFFFFFFFFFFF << 8;
        }
        return $result;
    }

    public static function uint8ToInt8(int $value): int {
        $value = $value & 0xFF;
        if (($value & 0x80) == 0) return $value;
        return $value | 0xFFFFFFFFFFFFFF00;
    }

    public static function uint16ToInt16(int $value): int {
        $value = $value & 0xFFFF;
        if (($value & 0x8000) == 0) return $value;
        return $value | 0xFFFFFFFFFFFF0000;
    }

    public static function uint32ToInt32(int $value): int {
        $value = $value & 0xFFFFFFFF;
        if (($value & 0x8000) == 0) return $value;
        return $value | 0xFFFFFFFF00000000;
    }

    public static function int8ToUInt8(int $value): int {
        return $value & 0xFF;
    }

    public static function int16ToUInt16(int $value): int {
        return $value & 0xFFFF;
    }

    public static function int32ToUInt32(int $value): int {
        return $value & 0xFFFFFFFF;
    }
}


/**
 * 文件操作及数据存取类
 * Class FileOperation
 * @package TamPub1
 * @property  int pos 当前指针的位置
 */
class FileOperation {
    private $fs = null;
    public $textCoding = "utf-8"; //System.Text.Encoding.Default.WebName; //2017-11新增默认编码形式，配合writeFixStringEx等
    public $filename = "";

    public function __get($name) {
        if ($name === "pos") {
            if ($this->fs == null) {
                return -1;
            } else {
                $temp = ftell($this->fs);
                return $temp ? $temp : -1;
            }
        } else return "";
    }

    public function __set($name, $value) {
    }

    public static function exists(string $filename): bool {
        return file_exists($filename);
    }

    public static function pathExists(string $path): bool {
        return is_dir($path);
    }

    public static function createDir(string $path): bool {
        return mkdir($path, 0777, true);
    }

    public static function deleteFile(string $filename): bool {
        return unlink($filename);
    }

    /**
     * 打开一个文件用来读取
     * @param string|null $filename 如果为null, 则需要提前指定filename
     * @return bool
     */
    public function openRead(string $filename = null): bool {
        if ($filename == null) $filename = $this->filename;
        $this->close();
        $this->filename = $filename;
        $fs = fopen($filename, "r");
        if (!$fs) {
            $this->fs = null;
            return false;
        }
        $this->fs = $fs;
        //reader = new System . IO . BinaryReader(fs, System . Text . Encoding . GetEncoding(textCoding));
        return true;
    }

    /**
     * 打开一个文件从末尾添加，如果文件不存在则新建
     * @param string|null $filename 如果为空，需要提前指定filename
     * @return bool
     */
    public function openAppend(string $filename = null): bool {
        if ($filename == null) $filename = $this->filename;
        $this->close();
        $this->filename = $filename;
        $fs = fopen($filename, "a");
        if (!$fs) {
            $this->fs = null;
            return false;
        }
        $this->fs = $fs;
        return true;
    }

    public function close(): void {
        if ($this->fs != null) fclose($this->fs);
        $this->fs = null;
    }

    public static function renameFile(string $oldFilename, string $newFilename): bool {
        return rename($oldFilename, $newFilename);
    }

    /**
     * 强制开启一个新文件进行写操作, 如果原文件存在则删除
     * @param string $filename null则需要提前指定filename
     * @return bool
     */
    public function openNew(string $filename = null): bool {
        if ($filename == null) $filename = $this->filename;
        $this->close();
        $this->filename = $filename;
        if (!self::deleteFile($filename)) return false;
        return $this->openAppend($filename);
    }

    private function writeBuff($buff): bool {
        if ($this->fs == null) return false;
        if (!fwrite($this->fs, $buff)) {
            return false;
        }
        return true;
    }

    private function readBuff(int $bytesRead): string {
        if ($this->fs == null) return "";
        $result = fread($this->fs, $bytesRead);
        return $result ? $result : "";
    }

    /**
     * 写入bool
     * @param bool $value
     * @return bool
     */
    public function writeBool(bool $value): bool {
        $buff = Converter::int8ToBin($value ? 1 : 0);
        return $this->writeBuff($buff);
    }

    public function writeInt32(int $value): bool {
        $buff = Converter::int32ToBin($value);
        return $this->writeBuff($buff);
    }

    public function writeUInt16(int $value): bool {
        $buff = Converter::uint16ToBin($value);
        return $this->writeBuff($buff);
    }

    public function writeWFixedString(string $value): bool {
        return $this->writeBuff($value);
    }

    public function writeFixedStringEx(string $value): bool {
        $value = mb_convert_encoding($value, $this->textCoding);
        return $this->writeBuff($value);
    }

    /**
     * 写入文件BOM头(Byte Order Mark)
     * @param string $encodingName
     * @return bool
     */
    public function writeEncodingHeader(string $encodingName = ""): bool {
        if (StringFunc::length($encodingName) <= 0) $encodingName = $this->textCoding;
        $encodingName = StringFunc::toLower($encodingName);
        if ($encodingName === "utf-8") {
            $this->writeBuff(chr(0xEF));
            $this->writeBuff(chr(0xBB));
            $this->writeBuff(chr(0xBF));
        } else if ($encodingName === "utf-16be") {
            $this->writeBuff(chr(0xFE));
            $this->writeBuff(chr(0xFF));
        } else if ($encodingName === "unicode") {
            $this->writeBuff(chr(0xFF));
            $this->writeBuff(chr(0xFE));
        }
        return true;
    }

    public function writeWString(string $value): bool {
        if (!$this->writeInt32(strlen($value))) return false;
        return $this->writeWFixedString($value);
    }

    /**
     * 读取bool
     * @return bool
     */
    public function readBool(): bool {
        $buff = $this->readBuff(1);
        if (strlen($buff) != 1) return false;
        return ord($buff) == 0 ? false : true;
    }

    public function readInteger(): int {
        $buff = $this->readBuff(4);
        return Converter::binToInt32($buff);
    }

    public function readUInt16(): int {
        $buff = $this->readBuff(2);
        return Converter::binToUInt16($buff);
    }

    public function readWFixedString(int $len): string {
        return $this->readBuff($len);
    }

    public function readFixedStringEx(int $len): string { //2017-11-14没测试过
        $result = $this->readBuff($len);
        return mb_convert_encoding($result, $this->textCoding);
    }

    /**
     * 从全路径的文件名提取路径名，末尾包含"\"或者"/"
     * @param string $filePathName 一个带路径的文件名
     * @return string
     */
    public static function extractFilePath(string $filePathName): string {
        $index = StringFunc::lastIndexOf($filePathName, '\\');
        if ($index < 0) {
            $index = StringFunc::lastIndexOf($filePathName, '/');
            if ($index < 0) {
                return $filePathName;
            }
        }
        return StringFunc::copy($filePathName, 0, $index + 1);
    }

    /**
     * 从全路径的文件名，提取单纯的文件名
     * @param string $filePathName
     * @return string
     */
    public static function extractFileName(string $filePathName): string {
        $index = StringFunc::lastIndexOf($filePathName, '\\');
        if ($index < 0) {
            $index = StringFunc::lastIndexOf($filePathName, '/');
            if ($index < 0) {
                return $filePathName;
            }
        }
        $index++;
        return StringFunc::copy($filePathName, $index, StringFunc::length($filePathName));
    }

    /**
     * 修改文件扩展名,包含"."
     * @param string $fileName 需要修改的文件名
     * @param string $newExt 新的扩展名，同样包含"."
     * @return string 修改好的东西
     */
    public static function changeFileExt(string $fileName, string $newExt): string {
        $index = StringFunc::lastIndexOf($fileName, '.');
        if ($index < 0) return $fileName . $newExt;
        $index++;
        return StringFunc::copy($fileName, 0, $index - 1) . $newExt;
    }

    /**
     * get file's ext, not include "."
     * @param string $filename filename can include filepath
     * @return string
     */
    public static function getFileExt(string $filename): string {
        $pos = StringFunc::lastIndexOf($filename, '.');
        if ($pos < 0) return "";
        if ($pos == StringFunc::length($filename) - 1) return "";
        return StringFunc::copy($filename, $pos + 1, 999999);
    }

    /**
     * find which seperator the file sturcture use, '/' or '\'
     * @param string $filePathName
     * @return string '/' or '\'
     */
    public static function getPathSeperator(string $filePathName): string {
        if (StringFunc::indexOf($filePathName, '/') >= 0) return '/';
        if (StringFunc::indexOf($filePathName, '\\') >= 0) return '\\';
        return '/';
    }

    /**
     * 在php中返回的是php文件的目录及文件名
     * @return string 当前运行文件的路径+文件名
     */
    public static function currentFilePathName(): string {
        return $_SERVER["SCRIPT_FILENAME"];
    }

    /**
     * 当前运行文件的文件名，不包含路径，在php中是当前php文件名
     * @return string
     */
    public static function currentFileName(): string {
        return self::extractFileName(self::currentFilePathName());
    }

    /**
     * 当前运行文件的路径，在php中是当前php的执行目录
     * @return string
     */
    public static function currentFilePath(): string {
        return self::extractFilePath(self::currentFilePathName());
    }

    /**
     * 从全路径的文件名中提取不含扩展名和路径的文件名，兼容linux和windows文件系统
     * @param $filePathName
     * @return string
     */
    public static function getFileNameWithoutExtension($filePathName): string {
        $filename = self::extractFileName($filePathName);
        $index = StringFunc::lastIndexOf($filename, '.');
        if ($index < 0) return $filename;
        return StringFunc::copy($filename, 0, $index);
    }

    public static function getFolderName(string $path): string {
        if ($path == "") return "";
        $path = StringFunc::deleteRearChar($path, '\\');
        $path = StringFunc::deleteRearChar($path, '/');
        $pos = StringFunc::lastIndexOf($path, '/');
        if ($pos < 0) {
            $pos = StringFunc::lastIndexOf($path, '\\');
            if ($pos < 0) return $path;
        }
        return StringFunc::copy($path, $pos + 1, 999999);
    }
}

/// <summary>2019-06-05 用于多线程访问某些公用数据的锁</summary>
class TamLocker {
    /**
     * @var \Threaded
     */
    private $lockObj;
    private $Busy = false;
    /**
     * @var int 毫秒单位的锁最大等待超时
     */
    public $LockTimeout = 10000;
    public $waitInterval = 5;

    /**
     * 锁定
     * @return bool 返回false表示出现了超时解锁的现象
     */
    public function Lock(): bool {
        //$this->lockObj->lock();
        $result = true;
        $StartTick = time();
        while ($this->Busy) {
            if ($this->LockTimeout > 0) {
                if (time() - $StartTick >= $this->LockTimeout) {
                    $this->Unlock();
                    $result = false;
                    break;
                }
            }
            usleep($this->waitInterval * 1000);
        };
        $this->Busy = true;
        //$this->lockObj->unlock();
        return $result;
    }

    public function Unlock(): void {
        $this->Busy = false;
    }

    /**
     * TamLocker constructor.
     * @param int $lockTimeout 毫秒单位的锁最大等待超时,0表示不需要超时
     * @param int $waitInterval 等待时查询的时间间隔，单位毫秒，推荐使用5ms即1秒扫描200次
     */
    public function __construct(int $lockTimeout = 10000, int $waitInterval = 5) {
        //$this->lockObj = new \Threaded();
        $this->LockTimeout = $lockTimeout;
        $this->waitInterval = $waitInterval;
    }
}

/**
 * Class StringBuilder 模拟C#的StringBuilder类
 * @package TamPub1
 */
class StringBuilder {
    public $buff = array();

    public function Append(string $value): void {
        array_push($this->buff, $value);
    }

    public function Clear(): void {
        $this->buff = array();
    }

    public function ToString(): string {
        return implode("", $this->buff);
    }
}

/**
 * Class ConfigurationManager An easy way to access php configuration file(php.ini)
 * @package TamPub1
 */
class ConfigurationManager {
    /**
     * @return string php config file(php.ini) path and name
     */
    public static function cfgFilename(): string {
        return php_ini_loaded_file();
    }

    public static function readString(string $section, string $key): string {
        $buff = parse_ini_file(self::cfgFilename(), true);
        if (!$buff) return "";
        if (!isset($buff[$section])) return "";
        $buff = $buff[$section];
        if (!isset($buff[$key])) return "";
        $buff = $buff[$key];
        return $buff;
    }

    public static function readInt(string $section, string $key): int {
        return (int)self::readString($section, $key);
    }
}


/**
 * 不同于StringData,本类将数据结构存储为可见的字符串
 * 2015/01/19 做了改造：以前的模式不符合普遍的传输协议，一个16bit数据应该将低位放在最前面
 * Class StringData2
 * @package TamPub1
 */
class StringData2 {
    public $buff = "";
    public $sp = 0;

    public function eof(): bool {
        return $this->sp >= StringFunc::length($this->buff);
    }

    public function appendByte(int $value): void {
        if ($value >= 0x10) {
            $this->buff .= dechex($value);
        } else {
            $this->buff .= '0' . dechex($value);
        }
    }

    public function appendWord(int $value): void {
        $this->appendByte($value & 0xFF);
        $this->appendByte(($value & 0xFF00) >> 8);
    }

    public function appendInt16(int $value): void {
        $this->appendWord(Converter::int16ToUInt16($value));
    }

    public function appendDWord(int $value): void {
        $this->appendWord($value & 0xFFFF);
        $this->appendWord(($value & 0xFFFF0000) >> 16);
    }

    public function appendInt32(int $value): void {
        $this->appendDWord(Converter::int32ToUInt32($value));
    }

    public function readByte(): int {
        if ($this->sp >= StringFunc::length($this->buff) - 1) {
            $this->sp = StringFunc::length($this->buff);
            return 0;
        }
        //byte $result;
        $result = hexdec(StringFunc::copy($this->buff, $this->sp, 2));
        $this->sp += 2;
        return $result;
    }

    public function readWord(): int {
        $result = $this->readByte();
        $result = $result | ($this->readByte() << 8);
        return $result;
    }

    public function readInt16(): int {
        return Converter::uint16ToInt16($this->readWord());
    }

    public function readDWord(): int {
        $result = $this->readWord();
        $result = $result | ($this->readWord() << 16);
        return $result;
    }

    public function readInt32(): int {
        return Converter::uint32ToInt32($this->readDWord());
    }

    public function readString(): string {
        $len = min($this->readInt32(), StringFunc::length($this->buff) - $this->sp);
        $result = StringFunc::copy($this->buff, $this->sp, $len);
        $this->sp += $len;
        return ($result);
    }

    public function readString8(): string {
        $len = min($this->readByte(), StringFunc::length($this->buff) - $this->sp);
        $result = StringFunc::copy($this->buff, $this->sp, $len);
        $this->sp += $len;
        return ($result);
    }

    public function readString16(): string {
        $len = min($this->readWord(), StringFunc::length($this->buff) - $this->sp);
        $result = StringFunc::copy($this->buff, $this->sp, $len);
        $this->sp += $len;
        return ($result);
    }

    public function appendString(string $value): void {
        $this->appendInt32(StringFunc::length($value));
        $this->buff .= $value;
    }

    public function appendString8(string $value): void {
        $value = StringFunc::copy($value, 0, min(0xff, StringFunc::length($value)));
        $this->appendByte(StringFunc::length($value));
        $this->buff .= $value;
    }

    public function appendString16(string $value): void {
        $value = StringFunc::copy($value, 0, min(0xffff, StringFunc::length($value)));
        $this->appendWord(StringFunc::length($value));
        $this->buff .= $value;
    }
}















